<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        //用于将嵌套的数组扁平化
        //方法一：递归调用处理
        Array.prototype.myFlat=function(depth=1){
            const result=[]
            for(let i=0;i<this.length;i++){
                if(Array.isArray(this[i])&&depth>0){
                    //如果当前元素是数组且depth大于0，就递归调用myFlat，depth减1
                    const flatArr=this[i].myFlat(depth-1);
                    result.push(...flatArr);//把扁平化后的数组展开后放到结果数组里
                }else{
                    result.push(this[i]);//如果不是数组，就直接放到结果数组里
                }
            }
            return result;
        }
        //测试
        const arr=[1,2,[3,4,[5,6]]];
        console.log(arr.myFlat(2));//[1,2,3,4,5,6]

        //方法2，reduce合并concat+递归调用
        Array.prototype.myFlat2=function(depth=1){
            const arr=this
            return arr.reduce((pre,cur)=>{
                if(Array.isArray(cur)&&depth>0){
                    return pre.concat(cur.myFlat2(depth-1))
                }else{
                    return pre.concat(cur)
                }
            },[])
        }

        // 1. 基础测试（默认depth=1）
            const arr1 = [1, [2, 3], [4, [5]]];
            console.log(arr1.myFlat()); // [1, 2, 3, 4, [5]]（只扁平1层）

            // 2. 指定深度测试（depth=2）
            console.log(arr1.myFlat2(2)); // [1, 2, 3, 4, 5]（扁平2层，完全扁平化）

            // 3. 无限深度测试（depth=Infinity）
            const arr2 = [1, [2, [3, [4]]]];
            console.log(arr2.myFlat2(Infinity)); // [1, 2, 3, 4]（任意嵌套都扁平为一维）

            // 4. 深度为0（不扁平化）
            console.log(arr1.myFlat(0)); // [1, [2, 3], [4, [5]]]（和原数组一致）
    </script>
</body>
</html>