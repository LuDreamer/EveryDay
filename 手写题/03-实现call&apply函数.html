<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        //call和apply都是改变函数this的指向，并执行函数
        //相当于给call函数的第一个参数添加了一个fn临时属性，然后以此参数当作函数执行时的this值

        function greet(animalName,animalName2){
            console.log(`Hello,${this.name}!我是${animalName},我和${animalName2}是好朋友`);

        }
        const person={name:'Wang'}
        const animal=['rabiit','tigger']
        //挂载到function原型上
        Function.prototype.myCall=function(_this,...rest){
            //处理上下文对象，_this可能为null或undefined，使用全局对象
            const context=_this??globalThis
            //创建唯一的临时属性，避免与原有属性冲突
            const fnKey=Symbol('fn')
            //将当前函数挂在到上下文对象上
            context[fnKey]=this
            //调用函数并返回结果
            const result=context[fnKey](...rest)
            //删除临时属性,避免污染上下文属性
              // 使用Reflect.deleteProperty更规范，返回布尔值表示删除是否成功
            Reflect.deleteProperty(context,fnKey)
            return result
        }
        greet.myCall(person,'tigger') // Hello, Wang

        //apply 方法和 call 方法的不同其实就是参数的不同，所以我们能轻易的写出 apply 方法
        Function.prototype.myApply=function(_this,args){
            const context=_this??globalThis
            const fnKey=Symbol('fn')
            //挂载
            context[fnKey]=this
            //调用
            const result = context[fnKey](...(args || [])); // args 可能为 null 或 undefined
            //删除临时属性
            Reflect.deleteProperty(context,fnKey)
            return result
        }
    

            

            console.log(greet.myApply(person, animal));
    </script>
</body>
</html>