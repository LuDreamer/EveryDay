<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        //数据类型
        function getType(target){
            return Object.prototype.toString.call(target).replace('[object ', '').replace(']', '').toLowerCase();
        }
        //是否为引用类型
        function isObject(target){
            return target instanceof Object
        }
        //判断是否可迭代
        function isIterable(target){
            return !!target[Symbol.iterator]
        }
        //创建相同类空对象
        function getInit(target){
            const sameCtor=target.constructor
            return new sameCtor()
        }
        //其他类型DeepClone
        function deepCloneOtherType(target){
            switch(getType(target)){
                case 'date':return new Date(target)
                case 'regexp':return new RegExp(target.source,target.flags)
                 case 'object': // 新增：处理普通对象（如 {a:1, b:{}}）
                    const copyObj = {};
                    for (let key in target) {
                       
                        if (target.hasOwnProperty(key)) {
                           
                            copyObj[key] = deepClone(target[key]);
                        }
                    }
                    return copyObj;
                default:
                    return target; // 其他类型直接返回（如 Function，通常不深拷贝函数）
            }
        }
        function deepClone(source){
            //是否为引用类型
            if(!isObject(source)){
                return source
            }
            if(isIterable(source)){
                let copy=getInit(source)
                const type = getType(source);

                if (type === 'map') {
                    // Map 深拷贝：键不深拷贝（通常为值类型），值递归深拷贝
                    source.forEach((value, key) => {
                        copy.set(key, deepClone(value));
                    });
                } else if (type === 'set') {
                    // Set 深拷贝：值递归深拷贝（避免嵌套引用关联）
                    source.forEach((value) => {
                        copy.add(deepClone(value));
                    });
                } else if (type === 'array') {
                    // 数组深拷贝：遍历每个元素并递归
                    for (let i = 0; i < source.length; i++) {
                        copy[i] = deepClone(source[i]);
                    }
                }
                return copy;
            } else {
                return deepCloneOtherType(source);
            }
            
        }

        let b = {
                a: 1,
            c: [1, 2, { d: 3 }], // 数组嵌套普通对象（验证深层拷贝）
                d: new Date(),
                e: /\.js$/,
                f: new Set([1, 2]),
                g: new Map(),
            }
            let x = deepClone(b);
    // 验证深拷贝结果（所有引用类型应完全独立，=== 为 false）
    console.log(x.f === b.f); // false（Set 深拷贝成功）
    console.log(x.c === b.c); // false（数组深拷贝成功）
    console.log(x.c[2] === b.c[2]); // false（数组嵌套对象深拷贝成功）
    console.log(x.d === b.d); // false（Date 深拷贝成功）
    console.log(x.e === b.e); // false（RegExp 深拷贝成功，flags 保留）
    console.log(x.g === b.g); // false（Map 深拷贝成功）
    </script>
</body>
</html>